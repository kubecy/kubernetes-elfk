# elasticsearch写入原理

## 1.倒排索引与分词

### 1.1.正排索引

>1. 正排索引就是最普通的索引排序方式。正排索引也是采取key-value pair的方式对数据进行保存，key是doc-id，value则可以存储多种内容，如doc的分词词表、doc所在网页的属性信息等。由此可见，正排索引可以随意添加数据，但如果你要查询某个单词在哪些文档中出现，那么你就不得不将全部文档都遍历一遍，效率极低。
>2. 正排索引指的是文档id到文档内容的映射，也就是将每个文档的内容存储在一个文档ID对应的数据结构中，便于快速地根据文档ID获取文档内容。例如，在关系型数据库中存储的数据，可以看做是一种正排索引的实现。

~~~shell
文档1: {"搜索引擎": [1], "是": [2], "强大": [3], "的": [4], "工具": [5]}
文档2: {"信息检索": [1], "对于": [2], "学术研究": [3], "非常": [4], "重要": [5]}
文档3: {"搜索引擎": [1], "和": [3], "信息检索": [5], "密切": [7], "相关": [9]}
~~~

### 1.2.倒排索引

>1. 倒排索引类似将正排索引反过来，以全部文档中出现的所有words建立一个词典（term dictionary ），然后对于term dictionary 中的每个词，它后面都会跟随一个链表，该链表就是倒排表 ，倒排表内存储着如下信息：
>   - 该词出现的doc-id
>   - 该词在某doc中的出现次数和出现位置
>2. 如此一来，倒排索引就可以在用户输入查询query时，将query分词成一个个token，然后将一个个token带到term dictionary 去“查字典”，然后获得出现该词的doc-id集合，最终在这若干个token对应的若干doc-id集合上做交集，得到最符合用户query查询的结果。由此可见，倒排索引大大加快了查询速度，然而一旦有新的文档加入文档库，你就要重新做一次"入库操作"，即建立倒排索引的操作。因为此时各个token在不同文档中的出现次数、以及每个token对应的 倒排表 都可能发生变化。

~~~shell
"搜索引擎": [1, 3]
"是": [1]
"强大": [1]
"的": [1]
"工具": [1]
"信息检索": [2, 3]
"对于": [2]
"学术研究": [2]
"非常": [2]
"重要": [2]
"和": [3]
"密切": [3]
"相关": [3]
~~~

在ES中，每个文档都被存储为一个JSON格式的文档，每个文档都有一个唯一的ID。ES使用倒排索引来存储每个词项出现的文档ID，以及每个文档中每个词项的出现位置等信息。这使得ES能够高效的搜索和查询文档。

>具体的例子：Hello world,this is a sample document 可以转化成如下的正排索引

~~~shell
document_id | position | term
------------|----------|-------
1           | 1        | Hello
1           | 2        | world
1           | 3        | this
1           | 4        | is
1           | 5        | a
1           | 6        | sample
1           | 7        | document
~~~

>可以看到，这个正排索引存储了文档ID、单词位置和单词本身。如果我们要查找包含单词document的文档，我们可以根据这个索引快速找到该单词所在的位置，并获取对应的文档ID
>
>
>
>相比之下，倒排索引存储了每个单词出现在哪些文档中，即存储了单词->文档ID的键值对，举个例子
>
>Document 1: Hello world, this is a sample document.
>
>Document 2: The quick brown fox jumps over the lazy dog.
>
>Document 3: The sky is blue, the grass is green.
>
>可以转化成如下的倒排索引

~~~shell
term     | document_ids
---------|-------------
Hello    | 1
world    | 1
this     | 1
is       | 1
a        | 1
sample   | 1
document | 1
The      | 2, 3
quick    | 2
brown    | 2
fox      | 2
jumps    | 2
over     | 2
the      | 2, 3
lazy     | 2
dog      | 2
sky      | 3
is       | 3
blue     | 3
grass    | 3
green    | 3
~~~

>可以看到，这个倒排索引存储了每个单词出现的文档ID，如果我们要查找包含单词document的文档，可以快速找到包含该单词的文档ID

## 2.写索引原理

### 2.1.数据复制模型

>Elasticsearch 中的每个索引都被划分为shard，每个shard 可以有多个副本，这些副本称为副本组，在添加或删除文档时必须保持同步。

### 2.2. 路由（routing）

>1. 在ELasticsearch中，会采用计算的方式来确定存储到哪个节点，计算公式如下：
>   - shard = hash(routing) % number_1 of_primary_shards
>     - routing值是一个任意字符串，它默认是_id但也可以自定义。
>     - 这个routing字符串通过哈希函数生成一个数字，然后除以主切片的数量得到一个余数(remainder)，余数的范围永远是0到number_of_primary_shards - 1，这个数字就是特定文档所在的分片。
>2. 这就是为什么创建了主分片后，不能修改的原因。因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。写入过程

### 2.3.写入过程

>1. 新建、索引和删除请求都是写(write)操作，它们必须在主分片上成功完成才能复制到相关的复制分片上。

![image-20241017233332447](./000.picture/image-20241017233332447.png)

>2. 在主分片和复制分片上成功新建、索引或删除一个文档必要的顺序步骤：
>   - 客户端给Node 1 发送新建、索引或删除请求。
>   - 节点使用文档的_id 确定文档属于分片0 。它转发请求到Node 3 ，分片0 位于这个节点上。
>   - Node 3 在主分片上执行请求，如果成功，它转发请求到相应的位于Node 1 和Node 2 的复制节点上。当所有的复制节点报告成功， Node 3 报告成功到请求的节点，请求的节点再报告给客户端。
>   - 客户端接收到成功响应的时候，文档的修改已经被应用于主分片和所有的复制分片。